package main

import (
	"time"
	"fmt"
)

// Алгоритм управляет работой канального вентилятора
// Алгоритм запускается на периодической основе через равные интервалы времени.
// В момент запуска анализируются доступные на этот момент данные датчиков.
//
// Основной алгоритм использует данные датчиков во влажных помещениях и в сухих помещениях.
// Наибольшее значение влажности во влажных помещениях сравнивается с наибольшим значением влажности
// в сухих помещениях. При разнице влажности более 10% алгоритм включает канальный вентилятор.
//
// Алгоритм продолжает контролировать разницу влажностей. При разнице влажности менее 5% алгоритм
// выключает вентилятор. Дополнительно контролируется темп падения влажности во влажных помещениях.
// Если влажность во влажном помещении не изменяется (с допуском +-3%) в течение 30 минут, то
// алгоритм выключает вентилятор и прекращает контроль на другие 30 минут. По истечении этого
// времени контроль возобновляется в обычном режиме.
//
// В любом случае (даже в последнем) алгоритм продолжает публиковать управляющие сигналы
// получатель использует это для измеения пульса алгоритма, чтобы понять, что сервис, управляющий
// вентилятором не завис и продолжает работать. Получатель должен уметь работать с повторяющимися
// управляющими сигналами.
// 
// Также, могут возникнуть ситуации, когда не поступают сигналы от датчиков. Если "умерли" все датчики
// сухих помещений, то алгоритм включает канальный вентилятор при достижении влажности во влажном помещении
// в 66%, а выключает - при достижении влажности 64%. Имеется ввиду наибольшая влажность во всех влажных
// помещениях.
//
// Если "умерли" все датчики влажных помещений, то алгоритм выключает канальный вентилятор. При появлении
// сигнала хотя бы от одного датчика во влажном помещении возобновляется обработка данных с основного
// алгоритма. И опять: пересылка сигналов отключения вентилятора продолжается на периодической основе,
// чтобы потребитель мог измерить пульс работы сервиса.


const calcTimeout = time.Second * 30
var calcTick *time.Ticker
var savedHumidity float64

func calcLoop() {
	for range calcTick.C {
		fmt.Println("Calc Tick")
		doCalc()
	}
}

func doCalc() {
	if !wetSensorsAlive {
		ventServiceState.off()
		return
	}
	
	if drySensorsAlive {
		wet := maxHumidity(wetSensors)
		dry := maxHumidity(drySensors)
		
		if wet - dry > 10 {
			ventServiceState.on()
		}
		if wet - dry < 5 {
			ventServiceState.off()
		}
	} else {
		wet := maxHumidity(wetSensors)
		
		if wet > 66 {
			ventServiceState.on()
		}
		if wet < 64 {
			ventServiceState.off()
		}
	}
}

func maxHumidity(arr []DHTSensorData) float64 {
	max := -1.
	for _, d := range arr {
		if d.Humidity > max {
			max = d.Humidity
		}
	}
	return max
}

func minHumidity(arr []DHTSensorData) float64 {
	min := 101.
	for _, d := range arr {
		if d.Humidity < min {
			min = d.Humidity
		}
	}
	return min
}
